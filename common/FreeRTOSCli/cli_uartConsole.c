/*
 * cli_uartConsole.c
 *
 *  Created on: 2023/09/19
 *      Author: ch.wang
 */
#include <FreeRTOS.h>
#include "FreeRTOS_CLI.h"
/* POSIX Header files */
#include <pthread.h>
#include <string.h>
/* POSIX Header files */
#include <semaphore.h>

/* Driver Header files */
#include <ti/drivers/GPIO.h>
#include <ti/drivers/UART2.h>

/* Driver configuration */
#include "ti_drivers_config.h"

/* Stack size in bytes */
#define THREADSTACKSIZE 1024

#define MAX_INPUT_LENGTH    50
#define MAX_OUTPUT_LENGTH   100

static sem_t sem;
static volatile size_t numBytesRead;
static const char * const pcWelcomeMessage = "FreeRTOS command server.\r\nType Help to view a list of registered commands.\r\n";


void uartConsoleStart(void);
void *uartConsoleThread(void *arg0);
void uartRead_cb(UART2_Handle handle, void *buffer, size_t count, void *userArg, int_fast16_t status);

/*
 *  ======== callbackFxn ========
 */
void uartRead_cb(UART2_Handle handle, void *buffer, size_t count, void *userArg, int_fast16_t status)
{
    if (status != UART2_STATUS_SUCCESS)
    { /* RX error occured in UART2_read() */ while (1) {} }

    numBytesRead = count;
    sem_post(&sem);
}

void *uartConsoleThread(void *arg0)
{
    const char breakLine[] = "\r\n";
    const char blank[] = " \b";
    char cRxedChar;
    UART2_Handle uart;
    UART2_Params uartParams;
    int32_t semStatus;
    uint32_t status = UART2_STATUS_SUCCESS;
    static char pcOutputString[ MAX_OUTPUT_LENGTH ], pcInputString[ MAX_INPUT_LENGTH ];
    int8_t cInputIndex = 0;
    BaseType_t xMoreDataToFollow;

    /* Call driver init functions */
    GPIO_init();
    /* Configure the LED pin */
    GPIO_setConfig(CONFIG_GPIO_LED_RED, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW);

    /* Create semaphore */
    semStatus = sem_init(&sem, 0, 0);

    if (semStatus != 0)
    { /* Error creating semaphore */ while (1) {} }

    /* Create a UART in CALLBACK read mode */
    UART2_Params_init(&uartParams);
    uartParams.readMode     = UART2_Mode_CALLBACK;
    uartParams.readCallback = uartRead_cb;
    uartParams.baudRate     = 115200;

    uart = UART2_open(CONFIG_DISPLAY_UART, &uartParams);
    if (uart == NULL)
    { /* UART2_open() failed */ while (1) {} }

    /* Pass NULL for bytesWritten since it's not used in this example */
    status = UART2_write(uart, pcWelcomeMessage, strlen( pcWelcomeMessage ), NULL);

    /* Loop forever echoing */
    while (1)
    {
        numBytesRead = 0;

        /* Pass NULL for bytesRead since it's not used in this example */
        status = UART2_read(uart, &cRxedChar, 1, NULL);

        if (status != UART2_STATUS_SUCCESS)
        { /* UART2_read() failed */ while (1) {} }

        /* Do not write until read callback executes */
        sem_wait(&sem);

        if (numBytesRead > 0)
        {
            status = UART2_write(uart, &cRxedChar, 1, NULL);
            if(cRxedChar == '\r' || cRxedChar == '\n')
            {
                status = UART2_write(uart, breakLine, 2, NULL);
                // then execute

                // debug
                //status = UART2_write(uart, pcInputString, cInputIndex, NULL);
                //status = UART2_write(uart, breakLine, 2, NULL);
                do{
                    // Send the command string to the command interpreter.
                    xMoreDataToFollow = FreeRTOS_CLIProcessCommand(
                                      pcInputString,    //The command string.
                                      pcOutputString,   //The output buffer.
                                      MAX_OUTPUT_LENGTH //The size of the output buffer.
                                  );
                    // Write the output generated by the command interpreter to theconsole.
                    status = UART2_write( uart, pcOutputString, strlen( pcOutputString ), NULL);
                } while( xMoreDataToFollow != pdFALSE );

                status = UART2_write(uart, breakLine, 2, NULL);
                cInputIndex = 0;
                memset( pcInputString, 0x00, MAX_INPUT_LENGTH );
            }
            else
            {
                if(cRxedChar == '\b')
                {
                    if( cInputIndex > 0 )
                    {
                        cInputIndex--;
                        pcInputString[ cInputIndex ] = ' ';
                    }
                    status = UART2_write(uart, blank, 2, NULL);
                }
                else
                {
                    if( cInputIndex < MAX_INPUT_LENGTH )
                    {
                        pcInputString[ cInputIndex ] = cRxedChar;
                        cInputIndex++;
                    }
                }
            }

            if (status != UART2_STATUS_SUCCESS)
            { /* UART2_write() failed */ while (1) {} }
        }
    }
}

void uartConsoleStart(void)
{
    pthread_t thread;
    pthread_attr_t attrs;
    struct sched_param priParam;
    int retc;
    /* Initialize the attributes structure with default values */
    pthread_attr_init(&attrs);

    /* Set priority, detach state, and stack size attributes */
    priParam.sched_priority = 1;
    retc                    = pthread_attr_setschedparam(&attrs, &priParam);
    retc |= pthread_attr_setdetachstate(&attrs, PTHREAD_CREATE_DETACHED);
    retc |= pthread_attr_setstacksize(&attrs, THREADSTACKSIZE);
    if (retc != 0)
    {
      /* failed to set attributes */
      while (1) {}
    }

    retc = pthread_create(&thread, &attrs, uartConsoleThread, NULL);
    if (retc != 0)
    {
      /* pthread_create() failed */
      while (1) {}
    }
}
