/*
 * uartControl.c
 *
 *  Created on: 2023¦~9¤ë25¤é
 *      Author: ch.wang
 */
#include <FreeRTOS.h>
#include "FreeRTOS_CLI.h"
/* POSIX Header files */
#include <pthread.h>
#include <string.h>
/* POSIX Header files */
#include <semaphore.h>

/* Driver Header files */
//#include <ti/drivers/GPIO.h>
#include <ti/drivers/UART2.h>

/* Driver configuration */
#include "ti_drivers_config.h"

/* Stack size in bytes */
#define THREADSTACKSIZE 1024

#define MAX_INPUT_LENGTH    50
#define MAX_OUTPUT_LENGTH   100

#define CLI_MODE            0x01    /* UART to commad line interface mode */
#define BLE_STREAM_MODE     0x02    /* UART to BLE characteristic mode */


uint8_t uUartIOMode = CLI_MODE;

static sem_t sem;
static volatile size_t numBytesRead;



void uartConsoleStart(void);
void *uartConsoleThread(void *arg0);
void uartRx_cb(UART2_Handle handle, void *buffer, size_t count, void *userArg, int_fast16_t status);
void uartCliIOFxn(UART2_Handle uart);

/*
 *  ======== callbackFxn ========
 */
void uartRx_cb(UART2_Handle handle, void *buffer, size_t count, void *userArg, int_fast16_t status)
{
    if (status != UART2_STATUS_SUCCESS)
    { /* RX error occured in UART2_read() */ while (1) {} }

    numBytesRead = count;
    sem_post(&sem);
}

void *uartConsoleThread(void *arg0)
{
    UART2_Handle uart;
    UART2_Params uartParams;
    int32_t semStatus;
    uint32_t status = UART2_STATUS_SUCCESS;

    //GPIO_init(); /* Call driver init functions */
    //GPIO_setConfig(CONFIG_GPIO_LED_RED, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW); /* Configure the LED pin */

    semStatus = sem_init(&sem, 0, 0); /* Create semaphore */

    if (semStatus != 0)
    { while (1) {} /* Error creating semaphore */ }

    /* Create a UART in CALLBACK read mode */
    UART2_Params_init(&uartParams);
    uartParams.readMode     = UART2_Mode_CALLBACK;
    uartParams.readCallback = uartRx_cb;
    uartParams.baudRate     = 115200;

    uart = UART2_open(CONFIG_DISPLAY_UART, &uartParams);
    if (uart == NULL)
    { while (1) {} /* UART2_open() failed */ }

    switch(uUartIOMode)
    {
    case BLE_STREAM_MODE:

        break;
    case CLI_MODE:
    default:
        uartCliIOFxn(uart);
        break;
    }

}

void uartConsoleStart(void)
{
    pthread_t thread;
    pthread_attr_t attrs;
    struct sched_param priParam;
    int retc;
    /* Initialize the attributes structure with default values */
    pthread_attr_init(&attrs);

    /* Set priority, detach state, and stack size attributes */
    priParam.sched_priority = 1;
    retc                    = pthread_attr_setschedparam(&attrs, &priParam);
    retc |= pthread_attr_setdetachstate(&attrs, PTHREAD_CREATE_DETACHED);
    retc |= pthread_attr_setstacksize(&attrs, THREADSTACKSIZE);
    if (retc != 0)
    { while (1) {} /* failed to set attributes */ }

    retc = pthread_create(&thread, &attrs, uartConsoleThread, NULL);
    if (retc != 0)
    { while (1) {} /* pthread_create() failed */ }
}

void uartCliIOFxn(UART2_Handle uart)
{
    const char breakLine[] = "\r\n";
    const char backspace[] = " \b";
    char cRxedChar;
    static char pcOutputString[ MAX_OUTPUT_LENGTH ], pcInputString[ MAX_INPUT_LENGTH ];
    int8_t cInputIndex = 0;
    BaseType_t xMoreDataToFollow;
    uint32_t status = UART2_STATUS_SUCCESS;
    static const char * const pcCliMessage = "FreeRTOS command line interface.\r\nType help to view a list of registered commands.\r\n";
    /* Pass NULL for bytesWritten since it's not used in this example */
    status = UART2_write(uart, pcCliMessage, strlen( pcCliMessage ), NULL);

    /* Loop forever echoing */
    while (1)
    {
        numBytesRead = 0;
        /* Pass NULL for bytesRead since it's not used in this example */
        status = UART2_read(uart, &cRxedChar, 1, NULL);

        if (status != UART2_STATUS_SUCCESS)
        { /* UART2_read() failed */ while (1) {} }

        sem_wait(&sem); /* Do not write until read callback executes */

        if (numBytesRead > 0)
        {
            status = UART2_write(uart, &cRxedChar, 1, NULL);
            if(cRxedChar == '\r' || cRxedChar == '\n')
            {
                status = UART2_write(uart, breakLine, 2, NULL);
                do{
                    // Send the command string to the command interpreter.
                    xMoreDataToFollow = FreeRTOS_CLIProcessCommand(
                                      pcInputString,    //The command string.
                                      pcOutputString,   //The output buffer.
                                      MAX_OUTPUT_LENGTH //The size of the output buffer.
                                  );
                    // Write the output generated by the command interpreter to the console.
                    status = UART2_write( uart, pcOutputString, strlen( pcOutputString ), NULL);
                } while( xMoreDataToFollow != pdFALSE );

                status = UART2_write(uart, breakLine, 2, NULL);
                cInputIndex = 0;
                memset( pcInputString, 0x00, MAX_INPUT_LENGTH );
            }
            else
            {
                if(cRxedChar == '\b')
                {
                    if( cInputIndex > 0 )
                    {
                        cInputIndex--;
                        pcInputString[ cInputIndex ] = ' ';
                    }
                    status = UART2_write(uart, backspace, 2, NULL);
                }
                else
                {
                    if( cInputIndex < MAX_INPUT_LENGTH )
                    {
                        pcInputString[ cInputIndex ] = cRxedChar;
                        cInputIndex++;
                    }
                }
            }

            if (status != UART2_STATUS_SUCCESS)
            { while (1) {} /* UART2_write() failed */ }
        }
    }
}

